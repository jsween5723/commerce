# 이벤트 드리븐

## 문제1 외부로직

현재 데이터플랫폼 전송등 외부 API가 동기적으로 진행되며  
외부로직의 성공여부, 네트워크, 지연에 따라 정상적으로 수행된 비즈니스로직이  
트랜잭션 롤백되어 성능과 기능 측면에서 좋지않다.

### 비동기 방식

단순히 멀티쓰레드 기능을 활용한 비동기로 처리해도 되지만,
외부로직과 관련된 코드가 application 레이어에 존재하면 맥락을 파악하기 어려워질 수 있다.  
지금은 하나지만 만약 저런 로직이 산재해 있다면, 유지보수 비용이 증가할 것이다.  
이벤트 발행 및 구독을 통해 파일을 분리해서 좀 더 유연한 코드를 작성해본다.

### 이벤트 방식

해당 기능을 비동기적으로 처리하기 위해 이벤트 방식으로 재설계한다.

## 문제2 도메인간 결합도

또한 현재 구조는 application레이어에서 모든 도메인과 결합도가 높다.    
추후 조직이 커질수록 각 팀이 알아야할 맥락이 커져 온보딩 비용이 커진다.

### 해결방안

DDD의 바운디드 컨텍스트 개념을 적용하고, 적절하게 나뉘어진 도메인 간 통신을  
이벤트 기반으로 전환하여 각 도메인은 이벤트 이외에는 자기자신의 맥락만 알도록한다.  
타 도메인을 외부로직처럼 관리하여 좀 더 영역을 명확히하고 팀별로 관리하기 쉬운 코드로 바꾼다.

## 도메인 범위 지정

![바운디드 컨텍스트](바운디드_컨텍스트.png)

주문의 경우 다른 도메인이 변경돼도 정보가 유지돼야한다.  
따라서 주문 시점의 정보로 해당 도메인에서 엔티티를 생성해 유지 및 사용한다.

정하는 기준은 실제 프로그램 이용 시 어떤 기능을 제공해야하는지를 기준으로 삼았다.

주문은 주문대상상품목록과 쿠폰의 할인율을 적용해 가격을 보여줘야한다.
또한 결제 여부를 확인할 수 있어야한다.

결제는 다양한 결제수단을 지원해야한다. 주문 이외에도 다양한 곳에서 사용될 수 있다.

상품은 검색이 주요한 역할이다. 주문 이외에도 이벤트 등 다양한 곳에서 사용될 수 있다.

쿠폰은 발급이 가능해야하고, 발급된 쿠폰을 조회할 수 있어야한다. 주문 이외에도 다양한 곳에 적용할 수 있다.

포인트는 충전을 할 수 있어야한다. 여러 도메인에서 사용, 충전 될 수 있는 여지가 있다.

생명주기와 재사용성을 고려했을 때 맥락은 저렇게 5가지로 구분했다.

## 이벤트 설계 (분산 트랜잭션 적용 전)

실선: BEFORE_COMMIT  
점선: AFTER_COMMIT+Async

BEFORE_COMMIT을 활용하고 Async를 적용하지 않음으로써 단일 스레드에서 실행된다.  
따라서 예외가 발생할 경우 커밋이 종료되기 전이므로 롤백이 진행된다.  
보상 트랜잭션을 발행하지 않아도 되므로 우선 해당방식을 차용하고,  
이후 각 도메인간 이벤트 발행이 카프카로 변경돼 비동기로 트랜잭션을 유지할 수 없을경우  
EventListener 및 보상트랜잭션 발행으로 분산트랜잭션을 구현한다.

따라서 우선은 AFTER_COMMIT+Async를 통한 분산 트랜잭션은 데이터 플랫폼 전송시에만 적용한다.

### 주문 생성

갈라진 이벤트를 검증하기 위해    
Order에 productStatus, couponStatus 추가    
TODO: 추후 분산 트랜잭션 적용 후 롤백여부 확인을 위해 OrderProcess.CreateStart 처럼 만들고 레디스 활용하여 관리  
TODO: 동기 처리중이기 때문에 재고, 쿠폰의 경우 콜렉션 전달하나 분산 트랜잭션 적용 후 단일처리로 변경

![주문 생성](주문생성_이벤트.png)

### 주문 결제

![주문 결제](주문결제_이벤트.png)

## 퍼블리셔, 이벤트, 리스너

이벤트 드리븐으로 변경하는 작업은 추후 MSA를 지원하기 위해서이다.
따라서 interfaces 패키지를 domain 별로 찢고 관리해본다.
이 때 이벤트의 경우 모든 도메인에서 접근이 가능해야하므로 domain/event에서 관리한다.
listener의 경우 interfaces/각도메인/event 에서 관리한다.
publisher의 경우 domain/각도메인 에서 관리한다.
이렇게 함으로써 패키지별로 분리하더라도 의존성이 변화될 필요가 없다.

## 분산 트랜잭션 적용시

트랜잭션이 분산될 경우 문제가 되는 지점은 다음과 같다.

### 동시성 문제

A 분산 트랜잭션이 3번째 단계에서 오류가 발생할 예정일 때

2번째 단계종료 후 B 분산 트랜잭션이 접근한다.   
그런데, A분산 트랜잭션이 롤백되기 전 작업된 정보를 조회하므로 동시성 문제가 발생한다.

#### 해결방법

분산락은 해제 시점을 알 수없는 코레오그라피 특성상 사용이 어렵다.  
이를 해결하기 위해 리스너에서 작업을 수행하기 전, 해당 애그리거트 루트에 대해 작업여부상태를 저장한다.  
작업이 모두 완료된 후 관련 애그리거트의 해당 상태를 변경하는 이벤트를 발행한다.  
다른 분산 트랜잭션은 해당 상태를 확인하고 일정시간 대기 후, 이벤트를 재발행한다.

### 롤백

분산 트랜잭션은 각각의 트랜잭션이 분리돼있기 때문에 롤백이 까다롭다.

#### 해결방법

각 최초이벤트 대해 롤백여부(주문생성이라면 key가 OrderCreateEvent+orderId)를 redis에 저장한다.  
특정 작업이 실패할 경우 롤백여부를 redis에 업데이트하고 롤백이벤트를 발행한다.  
각 이벤트 구독시 해당 값을 우선조회하여  
재귀적으로 해당 리스너에서 구독한 이벤트들의 롤백 이벤트를 발행한다.  


