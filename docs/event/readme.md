## 개요

현재 주문 및 결제 처리 시스템은 외부 API 호출(예: 데이터 플랫폼 전송 등)이 동기적으로 처리되어, 네트워크 지연이나 외부 서비스 실패 시 비즈니스 로직이 포함된 트랜잭션이 함께 롤백되는 문제가 있습니다. 이로
인해 성능 저하와 신뢰성 이슈가 발생합니다.

또한, 애플리케이션 계층에서 여러 도메인을 직접 호출함으로써 도메인 간 결합도가 높아지고 있어, 팀 규모가 커질수록 온보딩 비용과 유지보수 부담이 증가합니다.

이를 해결하기 위해 이벤트 드리븐(Event-Driven) 아키텍처와 DDD(Domain-Driven Design) 바운디드 컨텍스트 개념을 적용하여 애플리케이션 레이어를 간소화하고, 도메인 간 의존성을 이벤트로
분리해 유연하고 확장 가능한 구조로 개선합니다.

---

## 문제 정의

### 1. 동기 외부 로직 처리

* 외부 API 호출이 트랜잭션 내에서 동기적으로 실행되어, 외부 서비스 장애 시 전체 트랜잭션이 롤백됨
* 네트워크 지연에 의해 주요 비즈니스 로직 처리 성능이 저하됨

### 2. 도메인 간 높은 결합도

* 애플리케이션 계층에서 모든 도메인을 직접 참조하여 호출
* 기능이 산재할수록 팀 간 공유해야 할 지식 범위가 넓어져 온보딩 및 유지보수 비용 증가

## 해결 방안

### 1. 이벤트 드리븐 아키텍처 적용

* 동기 호출 대신, 이벤트 발행(Publish)/ 구독(Subscribe) 구조로 전환
* 외부 연동 로직을 이벤트 리스너로 분리하여 Application 레이어 단순화
* 파일 및 패키지 구조:

    * `domain/event/{발행주체도메인}Event`: 공용 이벤트 정의
    * `interfaces/{각도메인}/event/{각도메인}{발행주체도메인}EventListener`: 이벤트 리스너
    * `domain/{각도메인}/{발행주체도메인}publisher`: 이벤트 발행기 인터페이스

### 2. DDD 바운디드 컨텍스트 도입

* 기능 단위로 도메인(주문, 결제, 상품, 쿠폰, 포인트) 바운디드 컨텍스트 분리
* 각 바운디드 컨텍스트는 자체 엔티티 및 비즈니스 로직만 인식하며, 타 컨텍스트는 이벤트로만 상호작용

----

## 도메인 경계 및 책임

![바운디드 컨텍스트](바운디드_컨텍스트.png)

| 도메인 | 책임                                        |
|-----|-------------------------------------------|
| 주문  | 주문 대상 상품 목록 조회, 쿠폰 할인율 적용 가격 계산, 주문 상태 관리 |
| 결제  | 다양한 결제 수단 처리, 결제 상태 확인                    |
| 상품  | 상품 정보 조회 및 검색 기능 제공                       |
| 쿠폰  | 쿠폰 발급, 쿠폰 조회 및 유효성 검증                     |
| 포인트 | 포인트 충전, 포인트 사용 내역 관리                      |

주문은 주문대상상품목록과 쿠폰의 할인율을 적용해 가격을 보여줘야한다.
또한 결제 id를 확인할 수 있어야한다.

결제는 다양한 결제수단을 지원해야한다. 주문 이외에도 다양한 곳에서 사용될 수 있다.

상품은 검색이 주요한 역할이다. 주문 이외에도 이벤트 등 다양한 곳에서 사용될 수 있다.

쿠폰은 발급이 가능해야하고, 발급된 쿠폰을 조회할 수 있어야한다. 주문 이외에도 다양한 곳에 적용할 수 있다.

포인트는 충전을 할 수 있어야한다. 여러 도메인에서 사용, 충전 될 수 있는 여지가 있다.

생명주기와 재사용성을 고려했을 때 맥락은 저렇게 5가지로 구분했다.


----

## 이벤트 설계

### 이벤트 발행 시점

* **BEFORE\_COMMIT**: 도메인 내부 로직 완료 후, 커밋 직전 이벤트 발행(동기 실행), 롤백 가능
* **AFTER\_COMMIT + @Async**: 트랜잭션 커밋 완료 후, 비동기 처리로 외부 연동, 예외 롤백 x

BEFORE_COMMIT을 활용하고 Async를 적용하지 않아 단일 스레드에서 실행된다.  
따라서 예외가 발생할 경우 커밋이 종료되기 전이므로 롤백이 진행된다.  
보상 트랜잭션을 발행하지 않아도 되므로 우선 해당방식을 차용한다.

이후 각 도메인간 이벤트 발행이 카프카로 변경돼 비동기로 트랜잭션을 유지할 수 없을경우  
EventListener 및 보상트랜잭션 발행으로 분산트랜잭션을 구현한다.

### 주문 생성 플로우

실선: BEFORE_COMMIT  
점선: AFTER_COMMIT+Async
![주문 생성](주문생성_이벤트.png)
플로우가 갈라진 이벤트를 검증하기 위해    
Order에 productStatus, couponStatus 추가

TODO: 추후 분산 트랜잭션 적용 후 롤백여부 확인을 위해 OrderProcess.CreateStart 처럼 만들고 레디스 활용하여 관리  
TODO: 동기 처리중이기 때문에 재고, 쿠폰의 경우 콜렉션 전달하나 분산 트랜잭션 적용 후 단일처리로 변경

### 주문 결제 플로우

실선: BEFORE_COMMIT  
점선: AFTER_COMMIT+Async
![주문 결제](주문결제_이벤트.png)

AFTER_COMMIT+Async 처리는 데이터 플랫폼 전송시에만 적용한다.

----

## 분산 트랜잭션 고려사항

### 동시성 문제

* 특정 트랜잭션이 종료되기전 다른 트랜잭션이 중간결과물을 조회해 수정하는 경우 동시성 문제 발생

**해결책**

1. 리스너 시작 전, 각 도메인 애그리거트 엔티티의 처리 잠금 상태(pending)를 별도 저장소(Redis 등)에 기록
2. 모든 단계 완료 후, 최종 완료 상태 변경 이벤트 발행
3. 다른 트랜잭션은 잠금 상태 확인 후 일정 시간 대기하거나 재시도

### 롤백 처리

* 분산 트랜잭션 실패 시 전체 롤백을 원자적으로 처리하기 어려움

**해결책**

1. 최초 이벤트 ID(`OrderCreateEvent:<orderId>`)를 키로 Redis에 롤백 여부 저장
2. 처리 단계별 예외 발생 시, Redis에 롤백 플래그 업데이트 및 `CompensationEvent` 발행
3. 각 리스너에서 처리 이전에 롤백 플래그 확인 후, 롤백 이벤트 전파

## 요약 및 기대 효과

1. **비동기 외부 연동**: 트랜잭션 경계 분리로 지연 및 장애 영향 최소화
2. **도메인 결합도 완화**: 각 바운디드 컨텍스트는 이벤트 기반으로만 통신하여 모듈화 강화
3. **유지보수성 향상**: 파일/패키지 기준으로 관심사 분리, 코드 가독성 및 온보딩 부담 감소
4. **분산 트랜잭션 대응**: 보상 트랜잭션 및 상태 관리로 실패 복구 및 롤백 처리 가능
