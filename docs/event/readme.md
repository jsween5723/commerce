# 이벤트 드리븐

## 도메인 범위 지정

![바운디드 컨텍스트](바운디드_컨텍스트.png)

주문의 경우 다른 도메인이 변경돼도 정보가 유지돼야한다.  
따라서 주문 시점의 정보로 해당 도메인에서 엔티티를 생성해 유지 및 사용한다.

정하는 기준은 실제 프로그램 이용 시 어떤 기능을 제공해야하는지를 기준으로 삼았다.

주문은 주문대상상품목록과 쿠폰의 할인율을 적용해 가격을 보여줘야한다.
또한 결제 여부를 확인할 수 있어야한다.

결제는 다양한 결제수단을 지원해야한다. 주문 이외에도 다양한 곳에서 사용될 수 있다.

상품은 검색이 주요한 역할이다. 주문 이외에도 이벤트 등 다양한 곳에서 사용될 수 있다.

쿠폰은 발급이 가능해야하고, 발급된 쿠폰을 조회할 수 있어야한다. 주문 이외에도 다양한 곳에 적용할 수 있다.

포인트는 충전을 할 수 있어야한다. 여러 도메인에서 사용, 충전 될 수 있는 여지가 있다.

생명주기와 재사용성을 고려했을 때 맥락은 저렇게 5가지로 구분했다.

## 이벤트 설계 (분산 트랜잭션 적용 전)

실선: BEFORE_COMMIT  
점선: AFTER_COMMIT+Async

### 주문 생성

갈라진 이벤트를 검증하기 위해    
Order에 productStatus, couponStatus 추가    
TODO: 추후 분산 트랜잭션 적용 후 롤백여부 확인을 위해 OrderProcess.CreateStart 처럼 만들고 레디스 활용하여 관리  
TODO: 동기 처리중이기 때문에 재고, 쿠폰의 경우 콜렉션 전달하나 분산 트랜잭션 적용 후 단일처리로 변경

![주문 생성](주문생성_이벤트.png)

### 주문 결제

![주문 결제](주문결제_이벤트.png)

## 분산 트랜잭션 적용시

트랜잭션이 분산될 경우 문제가 되는 지점은 다음과 같다.

### 동시성 문제

A 분산 트랜잭션이 3번째 단계에서 오류가 발생할 예정일 때

2번째 단계종료 후 B 분산 트랜잭션이 접근한다.   
그런데, A분산 트랜잭션이 롤백되기 전 작업된 정보를 조회하므로 동시성 문제가 발생한다.

#### 해결방법

분산락은 해제 시점을 알 수없는 코레오그라피 특성상 사용이 어렵다.  
이를 해결하기 위해 리스너에서 작업을 수행하기 전, 해당 애그리거트 루트에 대해 작업여부상태를 저장한다.  
작업이 모두 완료된 후 관련 애그리거트의 해당 상태를 변경하는 이벤트를 발행한다.  
다른 분산 트랜잭션은 해당 상태를 확인하고 일정시간 대기 후, 이벤트를 재발행한다.

### 롤백

분산 트랜잭션은 각각의 트랜잭션이 분리돼있기 때문에 롤백이 까다롭다.

#### 해결방법

각 최초이벤트 대해 롤백여부(주문생성이라면 key가 OrderCreateEvent+orderId)를 redis에 저장한다.  
특정 작업이 실패할 경우 롤백여부를 redis에 업데이트하고 롤백이벤트를 발행한다.  
각 이벤트 구독시 해당 값을 우선조회하여  
재귀적으로 해당 리스너에서 구독한 이벤트들의 롤백 이벤트를 발행한다.  
